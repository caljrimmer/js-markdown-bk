

Server-side Javascript
====================

JavaScript has traditionally only run in the web browser. This has changed in recent years and is now increasingly used on the server-side too. There are a number reasons for this:

- Writing the so same code that runs on both the server and the client saves time and resources. One developer can create a whole application, front to back.
- JavaScript syntax can be utilised as a query language on a number of NoSQL databases (Mongo, Redis, CouchDB)
- Web servers like Nginx (more popular than Apache and IIS) have Javascript syntax configuration files
-  V8 javascript engine, which is the most popular server-side JavaScript engine, is very fast for certain applications
- Node.js has become very popular as a server-side JavaScript environment
- NPM provides a repository of thousands of useful modules for building, developing, testing and compiling JavaScript on the server.

In this chapter we are going to focus on the following Javascript server-side technologies:

- **Node.js** is an open-source, cross-platform runtime environment for developing server-side Web applications.
- **MongoDB** is open-source, NoSQL, document database.
- **NPM** is a package manager for Node.js.
- **Webpack** is a module bundlers are suited for big web applications. It helps you build and publish your applications.
- **Command Line Tools** are applications that allow you run command-line instructions. These instructions communicate directly with your computer and instruct it to perform various tasks.


Node.js
---------

Node.js is a server side JavaScript platform built on Google's V8 JavaScript Engine. Node.js was developed by Ryan Dahl in 2009 as a way to easily building fast and scalable network and web applications. 

Node.js uses an event-driven and single-threaded model that makes it lightweight and efficient. Event-driven means that there is a main loop that listens for events (user interactions, received messages, triggered prompts), and then fires a callback function when one of those events is detected. Node.js applications are therefore asynchronous.

**Asynchronous events explained**

Take the example of a cheese counter at a supermarket.

At some supermarkets, when you can ask for some cheese, the shop assistant will serve you and then, when finished, serve the next customer. This is a synchronous task. The ability to serve cheese to any number of customers is based on the speed and number of sales assistants. Queues are likely to form.

At other supermarkets, you get a ticket and wait for your turn to be served cheese. You are free to continue with the rest of your shopping until your ticket is called. This is an asynchronous task. The ability to serve cheese is still dependent on the number and speed of sales assistants but it is very unlikely queues will form.

**Advantages of Node.js**

The advantages to using Node.js in your stack include:

- **Speed**. It is very fast as it runs on the Googleâ€™s V8 engine, which compiles the JavaScript directly into machine code.
- **Standalone**. Node.js contains a built-in library to allow applications to act as a Web server without software such as Apache or IIS. We do still need to reverse proxy (i.e. route to the port your application runs on) but we can use Nginx which uses JavaScript syntax too. 
- **Community**. Node.js also provides a rich library of various JavaScript modules (via NPM) which simplifies the development of web applications.
- **Flexible**. You can create web services (like web sockets or http endpoints) or web applications or a combination of the two in one node instance. Node.js can do as much or as little as you like in your stack. 
- **Scalability**. One node instance runs on once CPU core. This means you can scale very easily both on one server or over a number of servers (via a load balancer) by just spinning up more instances on demand.

MongoDB
-----------
MongoDB is an open source database that uses a document-oriented, NoSQL data storage. NoSQL means that Instead of using tables and rows as in relational databases (SQL), MongoDB stores schema-less documents into collections. 

Documents comprise of a sets of key-value pairs (like JavaScript Object literal) and are the basic unit of data in MongoDB. Collections contain sets of documents, they are analogous to tables in relational databases.

```javascript
{
	"_id" : ObjectId("544b6a591edc6bb86933c304"), 
	"email" : "john.smith@hotmail.com"
	"name" : "John Smith"
}
```
Above is an example of a MongoDB record. The _id is auto-generated by MongoDB when a record is saved.

MongoDB allows records to be queried with javascript like syntax. You can perform simple CRUD (create, read, update, destroy) operations easily.

```javascript
db.users.save({
	email : "john.smith@hotmail.com",
	name : "John Smith"
});

db.users.find({
	email : "john.smith@hotmail.com"
});

db.users.update({
	email : "john.smith@hotmail.com"
},{
	name : "John Brown"
});

db.users.destroy({
	email : "john.smith@hotmail.com"
});
```

**Advantages of MongoDB**

- Schema-less records allow for flexibility in both what is stored now and how the data you store changes over time.

- Sharding, partitioning large databases into a larger number of smaller databases, improves performance.

- Replication, storing data records across multiple machines, enables enough redundancy to survive most network partitions and other system failures

- MongoDB is very fast at writing data records and can support a relative large write load.

- MongoDB has built in spacial functions. This means you can find stored data by querying a location by latitude and longitude with a radius (i.e. all results 5 miles from Bristol).

- MongoDB has a number of **NPM** packages that seamlessly integrate it into Node.js applications (eg. **mongoose**).

**NPM**

NPM is a package manager for Node.js and other Javascript projects. It is repository of thousands of packages which can be versioned and included in your web applications.

NPM allows you to specify all of your web application's dependencies inside a package.json file. The package.json defines the versions of the packages you need and also allows you to create scripts to either build, test or instantiate your Node.js application. 

```javascript
{
    "name": "my-web-application",
    "version": "0.0.1",
    "description": "a simple web application",
    "scripts": {
        "start": "node ./app.js"
    },
    "dependencies": {
        "express": "^3.4.7",
        "lodash": "^2.1.0"
    }
}
```
This is an example package.json. You can define meta data about your project, scripts to start your application and finally dependencies by name. You can search for dependencies to use in your web application at https://www.npmjs.com/.

Adding a package.json file to your Node.js application means anybody, at anytime can install (npm install) and run (npm start) your application. It also means you can publish your application to NPM to share it with other developers.

Webpack
-----------

Webpack is a module bundler. It takes of assets like javascript, images, css, files and directories and turns that into a structured, minified package that can be distributed via a web server.

Webpack supports advanced functionality such as compilation/transpilation (convert React JSX to browser friendly Javascript), intelligent asset loading (load assets only when your application requires them), hashing files (versioning to inhibit browser caching) and source maps (so an application can still be debugged in the browser). There are many more modules that can be added to perform other tasks.

Command Line Tools
-------------------------

The command line lets you communicate directly with your computer and instruct it to perform various tasks. 

We use command line to run **Node**, **Webpack** and **NPM**. We can also start, stop and query our **MongoDB**. Command line an essential medium for building and deploying your applications.

Most of the time, it is quicker to use command line to access information or perform development tasks then it is to us the normal graphical file system.

On a Mac, **terminal** (which comes natively installed) or **iterm**, are the main command line tools.

On a Window's PC, **Windows Command Prompt** (which comes natively installed), **PowerShell** or **Cygwin** are the main command line tools.

Creating an ES6 development setup
------------------------------

First, we need to find out what software is installed on your machine. You can do this via your preferred command line (**CLI**) tool.

**Node.js**

In your **CLI**, enter the following command

```unix
node -v
```

If you have **Node.js** already installed, then you should see the version returned (e.g. "v5.2.0"). 

If **Node.js** isn't installed, then you should get a *command not found* error. The error report will be slightly different on different machines, but will be similar.

**Installing**

Installing Node.js is simple. You just need to visit the official Node.js website and follow the instructions.

- Download the installer from https://nodejs.org.
- Run the installer
- Accept the default settings
- Restart your computer

You can test it has worked by re-running the above command.

**NPM**

**installing**

**NPM** should be installed when you install **Node.js**. You can check that this is the case by running the following in your **CLI**.

```unix
npm -v
```

If you have **NPM** already installed, then you should see the version returned (e.g. "3.2.0"). 

You can install the latest version of **NPM** at any point by running the following command.

```unix
sudo npm install npm -g
``` 

On Windows, you can drop the **sudo** but you should run it as administrator.

**Creating your package.json**

We first build our package.json to define both the application we are building and also the application dependencies.

```javascript
{
  "name": "my-es6-app",
  "version": "1.0.0",
  "description": "My ES6 app description",
  "scripts": {
    "watch": "webpack --watch"
  },
  "devDependencies": {
    "babel-core": "^6.0.20",
    "babel-loader": "^6.0.1",
    "babel-preset-es2015": "^6.0.15",
    "webpack": "^1.12.2"
  }
}
```

We add some meta data about our project, two scripts which we can run in our CLI tool, and development dependencies to compile our ES6 code to backwards compatible native JavaScript code.

>**Tip**
>
> You can version your dependencies by requesting the exact version you wish, any major version (prefix version with ^) or any minor version (prefix version with ~)

**Create your Webpack config**

Our webpack config will map where our code is, run it through **Babel** which compiles our ES6 javascript to native Javascript, and then we output it to a **bundle.js** file.

```javascript
var path = require('path');
var webpack = require('webpack');

module.exports = {
    entry: './src/index.js',
    output: {
        path: __dirname,
        filename: 'bundle.js'
    },
    module: {
        loaders: [
            {
	            test: /\.js$/,
                loader: 'babel-loader',
                exclude: '/node_modules/',
                query: {
                  presets: 'es2015'
                }
            }
        ]
    }
};
```

We use commonJS to require **webpack** and a native node package called **path**. We aren't using the ES6 import syntax as this is not currently supported in **Node**.

The **path** package is used to find the directory the webpack config file sits in on your computer.

In the webpack config, we define the **entry** script to your ES6 application code and the **output** script where your compiled native Javascript code goes too.

Finally, in **module**, we define the ES6 compilation steps using **Babel** as our compiler.

**Create Index.html**

We need a HTML page to host our application code. The HTML needs to reference our compiled **bundle.js**.

```javascript
<!doctype html>
<html>
	<head>
	    <meta charset="UTF-8">
	    <title>ES6 app</title>
	</head>
	<body>
		<script src="bundle.js"></script>
	</body>
</html>
```

**File structure**

Let us bring it all the files together into one folder.

```unix
/app
  - package.json
  - webpack.config.js
  - index.html
  /src
	- index.js
```

We are now ready to build our app and develop our code. In your CLI tool, navigate to the **app** folder you have created.

```unix
npm install
npm run watch
```

Run **npm install** which will pull in the app development dependencies. Finally **npm run watch** which will automatically compile on any save on a file in the **src** directory.

After running the NPM commands, the new file structure will look like:

```unix
/app
  - package.json
  - webpack.config.js
  - index.html
  - bundle.js
  /src
	- index.js
  /node_modules
```

The **bundle.js** contains all your compiled code. The **node_modules** contains all the development dependencies. The **src** contains all your ES6 code.



 Webpack for React development
---------------------------------------

We can add to our ES6 webpack setup to also compile any React code. We need to add some extra dependencies to **package.json**.

```javascript
...
  "dependencies": {
    "react": "^0.14.3",
    "react-dom": "^0.14.3"
  },
  "devDependencies": {
    "babel-core": "^6.0.20",
    "babel-loader": "^6.0.1",
    "babel-preset-es2015": "^6.0.15",
    "babel-preset-react": "^6.0.15",
    "webpack": "^1.12.2"
  }
...
```

We have added **react** and **react-dom** to dependencies and **babel-preset-react** to devDependencies.

**Dependencies** are used in your application code whereas **devDependencies** are used to help build your application.

Next we need add a new preset to our **webpack.config.js**.

```javascript
...
module: {
    loaders: [
        {
         test: /\.js$/,
            loader: 'babel-loader',
            query: {
              presets: ['es2015','react']
            }
        }
    ]
}
...
```

This means now webpack will compile our ES6 and React code to native JavaScripts that it will run on the majority of browsers.



 Webpack for deploying your web application
-------------------------------------------------------

When we are looking to deploy your web applications, you need to consider the size of the assets and versioning the assets. We want to create a small footprint, quick loading web application, that will always show the freshest code to our users.

Assets are all the static files of your application. The complied JavaScript, the stylesheets, the images and downloadable files (pdf, mp3 etc.). We will use webpack to put these all in one folder, compressed, rename the files and create a source map for debugging.

First let's add versioning to our bundled Javascript via our webpack config file.

```javascript
...
output: {
    path: __dirname,
    filename: 'bundle.js',
    chunkFilename: '[name]-[chunkhash].js',
}
...
```





We describe in the last chapter how to test React components. We used mocha, expect and JSDom as our test framework components. 


**MongoDB**

**installing**

MongoDB can be difficult to install for Windows PC's if you don't have administrator access to your machine. MongoDB is easier to install on a Mac. We shan't go into much detail on how to install MongoDB here but it is well documented here:

https://docs.mongodb.com/manual/administration/install-community/

There are many resources on the internet which will help you set up MongoDB and set it as a service on your computer.

From this point on, we shall assume you have your MongoDB console mapped to **mongo** in your CLI tool.

```unix
mongo
```

This will start your mongo console where you can query and manage your mongo instance.

We can use a build setup to manage our application dependencies, compile our code, minify, version, run linting and test. We create an environment that will help us build, test and deploy our application.

